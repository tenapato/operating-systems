{"filter":false,"title":"Lab9SolucionProfe.c","tooltip":"/Lab9SolucionProfe.c","undoManager":{"mark":0,"position":0,"stack":[[{"start":{"row":0,"column":0},"end":{"row":146,"column":1},"action":"insert","lines":["// Patricio Tena a01027293","// Francisco Acu√±a a01027294","","#include <stdio.h>","#include <stdlib.h>","#include <pthread.h>","#include <semaphore.h>","#include <unistd.h>","#define FULLCOUNT 5","","int count=0;","_Atomic int pid=0;","pthread_mutex_t queueLock;","sem_t full, empty;","typedef struct Processes{","\tint id;","\tint remainingTime;","\tstruct Processes *next;","} Process;","","Process *front;","","Process *createProcess(int id, int remainingTime){","\tProcess *toAdd=(Process *)malloc(sizeof(Process));","\ttoAdd->id=id;","\ttoAdd->remainingTime=remainingTime;","\ttoAdd->next=NULL;","\treturn toAdd;","}","void enqueue(Process *toAdd){","\tpthread_mutex_lock(&queueLock);","\tif(front==NULL){","\t\tfront=toAdd;","\t}else{","\t\tProcess *temp=front;","\t\twhile(temp->next!=NULL){","\t\t\ttemp=temp->next;","\t\t}","\t\ttemp->next=toAdd;","\t}","\tcount++;","\tpthread_mutex_unlock(&queueLock);","}","","Process *dequeue(){","\tpthread_mutex_lock(&queueLock);","\tProcess *toReturn=front;","\tfront=front->next;","\tcount--;","\ttoReturn->next=NULL;","\tpthread_mutex_unlock(&queueLock);","\treturn toReturn;","}","","void printQueue(){","\tProcess *temp=front;","\tprintf(\"Total:%d;\", count);","\twhile(temp!=NULL){","\t\t\tprintf(\"id:%d,rT:%d;\",temp->id, temp->remainingTime);","\t\t\ttemp=temp->next;","\t}","\tprintf(\"\\n\");","}","","void *user(void *args){//producer","\tint id=*(int *)args;","\tint processesToCreate=(rand()%10)+5;","\tfor(int i=0; i<processesToCreate; i++){","\t\tsem_wait(&empty); //waits til ampty is different than 0 / decrease the value of empty","        int rTime=rand()%30;","        int currentPid=pid++;","        printf(\"User %d: created process %d with burst %d\\n\",id, currentPid, rTime);","        ","        enqueue(createProcess(currentPid, rTime));","        sem_post(&full); //increases the value of full by 1","    }","}","","void *cpu(void *args){//consumer","\tint id=*(int *)args;","\tint quantum=5;","\t//while(count>0){","\tint counterNoproc= 0;","\twhile(1){","\t\tint result=sem_trywait(&full);","\t\tif(result==-1){//semaphora cannot be decrease, there is no process in the queue","\t\t\tcounterNoproc++;","\t\t\tif(counterNoproc==3){","\t\t\t\tprintf(\"Ready queue empty 3 times for CPU %d. Exiting\\n\",id);","\t\t\t\tbreak;","\t\t\t}","\t\t\t","\t\t\tprintf(\"CPU %d did not found a process in the queue\\n\", id);","\t\t\tsleep(5);","\t\t\tcontinue;","\t\t}else{","\t\t\tcounterNoproc=0;","\t\t}","\t\t","\t    Process *p=dequeue();","\t    ","\t    printf(\"CPU %d is loading process %d\\n\",id, p->id);","\t    int i;","\t    for(i=0; i<quantum; i++){","\t        p->remainingTime--;","\t        if(p->remainingTime==0){","\t            break;","\t        }else if(rand()%100<10){","\t            break;","\t        }","\t    }","\t    if(p->remainingTime==0){","\t    \t","\t        printf(\"Process %d finished excecution\\n\", p->id);","\t        sem_post(&empty);","\t    }else{ ","\t        if(i<quantum){","\t            printf(\"Process %d preempted due I/O with remaining time %d\\n\", p->id, p->remainingTime);","    \t    }else{","    \t        printf(\"Process %d preempted with remaining time %d\\n\", p->id, p->remainingTime);","    \t    }","    \t    enqueue(p);","    \t    sem_post(&full);","\t    }","\t}","}","","","","","int main(){","   ","\tpthread_t user1, cpu1, user2;","\tpthread_mutex_init(&queueLock, NULL);","\tsem_init(&full, 0, 0); //initializing the semaphore with 0 spaces in the queue","\tsem_init(&empty, 0, FULLCOUNT);","\tint id1=1; ","\tint id2=2;","\tpthread_create(&user1, NULL, user, (void *)&id1);","\t//pthread_create(&user2, NULL, user, (void *)&id2);","\tpthread_create(&cpu1, NULL, cpu, (void *)&id1);","\tpthread_join(user1, NULL);","\t//pthread_create(&user2, NULL, user, (void *)&id2);","\t//pthread_join(user2, NULL);","\tpthread_join(cpu1, NULL);","\treturn 0;","}"],"id":1}],[{"start":{"row":82,"column":1},"end":{"row":97,"column":3},"action":"remove","lines":["int counterNoproc= 0;","\twhile(1){","\t\tint result=sem_trywait(&full);","\t\tif(result==-1){//semaphora cannot be decrease, there is no process in the queue","\t\t\tcounterNoproc++;","\t\t\tif(counterNoproc==3){","\t\t\t\tprintf(\"Ready queue empty 3 times for CPU %d. Exiting\\n\",id);","\t\t\t\tbreak;","\t\t\t}","\t\t\t","\t\t\tprintf(\"CPU %d did not found a process in the queue\\n\", id);","\t\t\tsleep(5);","\t\t\tcontinue;","\t\t}else{","\t\t\tcounterNoproc=0;","\t\t}"],"id":2}]]},"ace":{"folds":[],"scrolltop":1195.5,"scrollleft":0,"selection":{"start":{"row":107,"column":18},"end":{"row":107,"column":33},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":95,"state":"start","mode":"ace/mode/c_cpp"}},"timestamp":1605579359126,"hash":"4a886c171760e623bc17934f48d2fa52081f8093"}